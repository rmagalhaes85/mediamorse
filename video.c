#include <cairo.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "parser.h"
#include "config.h"
#include "token.h"
#include "video.h"
#include "util.h"

typedef struct frame_data_s {
  const char *glyph_text;
  unsigned char *frame_buffer;
  struct frame_data_s *next;
} frame_data_t;

static frame_data_t *frames_cache = NULL;

static void getFrame(const config_t *config, const char *glyph_text,
    unsigned char **frame_buffer) {
  frame_data_t *tmp, *new_frame;
  int frame_size;

  tmp = frames_cache;
  while (tmp != NULL) {
    if (strcmp(tmp->glyph_text, glyph_text) == 0) {
      *frame_buffer = tmp->frame_buffer;
      return;
    }
    tmp = tmp->next;
  }

  frame_size = config->video_height * config->video_width * sizeof(unsigned char) * 3;

  // the cairo-related code below was generated by AI (ChatGPT) using the
  // following prompt:
  //
  // I will ask a code snippet using the Cairo library, in C. I want to
  // generate a rectangular canvas. The background is black. The canvas's
  // aspect ratio is 16:9. In the middle of the rectangle, there's gonna be a
  // letter A, in white. At the end of the snippet, I want to obtain an array
  // of bytes representing each pixel of that image. Each pixel should be
  // represented by 3 bytes, representing the RGB components

  // Create image surface and context
  cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_RGB24,
      config->video_width, config->video_height);
  cairo_t *cr = cairo_create(surface);

  // Fill background with black
  cairo_set_source_rgb(cr, 0, 0, 0); // Black
  cairo_paint(cr);

  // Draw white letter "A" in the center
  cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
  cairo_set_font_size(cr, config->video_height * 0.75); // Scale font to 75% of height

  cairo_text_extents_t extents;
  cairo_text_extents(cr, "A", &extents);

  double x = (config->video_width - extents.width) / 2 - extents.x_bearing;
  double y = (config->video_height - extents.height) / 2 - extents.y_bearing;

  cairo_move_to(cr, x, y);
  cairo_set_source_rgb(cr, 1, 1, 1); // White
  cairo_show_text(cr, "A");

  cairo_surface_flush(surface);

  // Extract raw pixel data (RGB)
  unsigned char *data = cairo_image_surface_get_data(surface);
  int stride = cairo_image_surface_get_stride(surface);
  unsigned char *rgb_data = malloc(frame_size); // RGB (3 bytes per pixel)

  for (int y = 0; y < config->video_height; y++) {
    unsigned char *src_row = data + y * stride;
    for (int x = 0; x < config->video_width; x++) {
      unsigned char *pixel = src_row + x * 4; // CAIRO_FORMAT_RGB24 uses
                                              // 4 bytes (ARGB 32-bit)
      int i = (y * config->video_width + x) * 3;
      rgb_data[i + 0] = pixel[2]; // Red
      rgb_data[i + 1] = pixel[1]; // Green
      rgb_data[i + 2] = pixel[0]; // Blue
    }
  }

  cairo_destroy(cr);
  cairo_surface_destroy(surface);

  new_frame = (frame_data_t *) fmalloc(sizeof(frame_data_t));
  new_frame->glyph_text = strdup(glyph_text);
  new_frame->next = NULL;
  new_frame->frame_buffer = rgb_data;
}

static void uninitializeVideo() {
  // free frames_cache nodes and their respective attributes, especially the
  // frame buffers
}

void writeVideo(const config_t *config, const token_bag_t *token_bag,
    const char *video_filename) {
}
