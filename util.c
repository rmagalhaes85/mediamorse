#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>

#include "util.h"

#ifdef _WIN32
    #define INVALID_FILENAME_CHARS "<>:\"/|?*"
#else
    #define INVALID_FILENAME_CHARS "\0"
#endif

void *fmalloc(size_t size) {
  void *pt = malloc(size);
  if (pt == NULL) {
    fprintf(stderr, "Error allocating %d bytes. Aborting.\n", size);
    exit(1);
  }
  return pt;
}

void *frealloc(void *ptr, size_t new_size) {
  void *pt = realloc(ptr, new_size);
  if (pt == NULL) {
    fprintf(stderr, "Error allocating %d bytes. Aborting.\n", new_size);
    exit(1);
  }
  return pt;
}

// generated by chatGPT. Prompt: please generate a function to validate if a string in
// C contains a valid filename
int is_valid_filename(const char *filename) {
    if (!filename || !*filename) return 0; // Empty string or NULL
    if (strcmp(filename, ".") == 0 || strcmp(filename, "..") == 0) return 0;

    size_t len = strlen(filename);
    if (len > NAME_MAX) return 0; // NAME_MAX from <limits.h>

    for (size_t i = 0; i < len; ++i) {
        if (strchr(INVALID_FILENAME_CHARS, filename[i])) return 0;
        if ((unsigned char)filename[i] < 32) return 0; // Control chars
    }

#ifdef _WIN32
    // Reserved Windows device names (case-insensitive)
    const char *reserved[] = {
        "CON", "PRN", "AUX", "NUL",
        "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
        "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9",
        NULL
    };
    char upper_name[NAME_MAX + 1];
    strncpy(upper_name, filename, NAME_MAX);
    upper_name[NAME_MAX] = '\0';
    for (size_t i = 0; i < strlen(upper_name); ++i) {
        upper_name[i] = toupper((unsigned char)upper_name[i]);
    }
    for (int i = 0; reserved[i]; ++i) {
        if (strcmp(upper_name, reserved[i]) == 0) return 0;
    }
#endif

    return 1; // Passed all checks
}

// generated by ChatGPT. Prompt: List safer alternatives to popen
int run_and_capture(const char *cmd, char *const argv[]) {
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return -1;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        return -1;
    }

    if (pid == 0) {
        // Child: set up output pipe
        close(pipefd[0]); // Close read end
        dup2(pipefd[1], STDOUT_FILENO); // Redirect stdout to pipe
        close(pipefd[1]);

        execvp(cmd, argv);
        perror("execvp");
        _exit(EXIT_FAILURE);
    } else {
        // Parent: read from pipe
        close(pipefd[1]); // Close write end
        char buffer[256];
        while (fgets(buffer, sizeof(buffer), fdopen(pipefd[0], "r"))) {
            fputs(buffer, stdout);
        }
        close(pipefd[0]);
        waitpid(pid, NULL, 0);
    }

    return 0;
}

// Generated by ChatGPT. Prompt: please, display the secure command runner with
// user-supplied arguments
// Securely run a command with arguments
int run_command(const char *cmd, char *const argv[]) {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return -1;
    }

    if (pid == 0) {
        // Child process
        execvp(cmd, argv);
        perror("execvp failed"); // only reached if exec fails
        _exit(EXIT_FAILURE);
    } else {
        // Parent process
        int status;
        if (waitpid(pid, &status, 0) == -1) {
            perror("waitpid failed");
            return -1;
        }

        if (WIFEXITED(status)) {
            return WEXITSTATUS(status); // return child's exit code
        } else {
            fprintf(stderr, "Child did not terminate normally\n");
            return -1;
        }
    }
}
